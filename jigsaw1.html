<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fun Jigsaw Puzzle ðŸŽ‰</title>

<style>
    body {
        margin: 0;
        font-family: 'Comic Sans MS', 'Segoe UI', Tahoma, sans-serif;
        background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
        text-align: center;
        min-height: 100vh;
        padding-bottom: 200px; 
        overflow-x: hidden;
        user-select: none;
    }

    h1 {
        color: #ff6b6b;
        padding: 20px 10px;
        margin: 0;
        font-size: 2.5em;
        text-shadow: 2px 2px 0px white, 4px 4px 8px rgba(0,0,0,0.1);
        animation: float 3s infinite ease-in-out;
    }

    @keyframes float {
        0%, 100% { transform: translateY(0) rotate(-1deg); }
        50% { transform: translateY(-8px) rotate(1deg); }
    }

    .progress {
        width: 90%;
        max-width: 500px;
        height: 25px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 20px;
        margin: 10px auto 20px auto;
        border: 3px solid white;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        overflow: hidden;
    }

    .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #f6d365 0%, #fda085 100%); /* Warmer, happier color */
        border-radius: 15px;
        transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .container {
        max-width: 500px;
        margin: auto;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 24px;
        padding: 20px;
        box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        border: 4px solid white;
    }

    #puzzleBoard {
        display: grid;
        gap: 0px; 
        justify-content: center;
        background: #f0f4f8;
        padding: 20px;
        border-radius: 16px;
        box-shadow: inset 0 4px 10px rgba(0,0,0,0.05);
        width: max-content; 
        margin-left: auto;
        margin-right: auto;
    }

    .slot {
        position: relative;
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
    }

    #pieces {
        display: flex;
        flex-wrap: nowrap; 
        overflow-x: auto;  
        overflow-y: hidden;
        align-items: center;
        gap: 10px;
        padding: 15px 20px;
        background: #ffffff;
        border-top: 4px solid #a1c4fd;
        border-radius: 24px 24px 0 0;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        min-height: 140px;
        box-shadow: 0 -10px 25px rgba(0,0,0,0.1);
        z-index: 500;
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #pieces::-webkit-scrollbar { height: 14px; }
    #pieces::-webkit-scrollbar-track { background: #f0f4f8; border-radius: 10px; margin: 0 20px; }
    #pieces::-webkit-scrollbar-thumb { background: #ff6b6b; border-radius: 10px; border: 2px solid #ffffff; }

    .piece {
        cursor: grab;
        filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
        transition: transform 0.1s;
        touch-action: none;
        flex-shrink: 0; 
    }

    .piece.dragging {
        cursor: grabbing;
        transform: scale(1.1) rotate(5deg);
        filter: drop-shadow(0 15px 20px rgba(0,0,0,0.3));
        z-index: 1000 !important;
    }

    /* NEW: Bouncy animation when placed correctly */
    @keyframes snapIn {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); filter: brightness(1.2); }
        100% { transform: scale(1); filter: brightness(1); }
    }

    .piece.placed {
        filter: none; 
        cursor: default;
        z-index: 10;
        animation: snapIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy math */
    }

    /* NEW: Sparkles for correct drops */
    .sparkle {
        position: absolute;
        width: 8px;
        height: 8px;
        background: #ffd700;
        border-radius: 50%;
        pointer-events: none;
        z-index: 1001;
        box-shadow: 0 0 6px #ffae00;
        animation: flyOut 0.6s ease-out forwards;
    }

    @keyframes flyOut {
        0% { transform: translate(0, 0) scale(1); opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    /* NEW: Wrong drop wobble animation on the tray */
    @keyframes wobble {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px) rotate(-1deg); }
        75% { transform: translateX(5px) rotate(1deg); }
    }
    .wobble-tray { animation: wobble 0.3s; }

    #result {
        font-size: 28px;
        font-weight: bold;
        color: #ff6b6b;
        margin-top: 20px;
        text-shadow: 2px 2px 0px white;
        opacity: 0;
        transition: opacity 0.5s;
    }

    #confetti {
        position: fixed;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 9999;
    }
</style>
</head>

<body>

<h1>ðŸ§© Magical Jigsaw! âœ¨</h1>

<div class="progress">
    <div class="progress-bar" id="progressBar"></div>
</div>

<div class="container">
    <div id="puzzleBoard"></div>
</div>

<div id="pieces"></div>

<div id="result">ðŸŽ‰ Awesome! You did it! ðŸŽ‰</div>
<canvas id="confetti"></canvas>

<script>
    // --- AUDIO SYNTHESIZER (NO MP3s NEEDED!) ---
    // This creates fun, retro video game style sounds using math.
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function playTone(frequency, type, duration, volume = 0.1) {
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
        
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Sound Triggers
    const sfxPickup = () => playTone(500, 'sine', 0.1, 0.05); // Soft bloop
    const sfxSnap = () => {
        playTone(800, 'triangle', 0.15, 0.1); // Bright chime
        setTimeout(() => playTone(1200, 'sine', 0.2, 0.05), 50); // Little sparkle echo
    };
    const sfxError = () => playTone(200, 'sawtooth', 0.2, 0.05); // Low boop
    const sfxWin = () => {
        // Happy little melody!
        setTimeout(() => playTone(400, 'sine', 0.2, 0.1), 0);
        setTimeout(() => playTone(500, 'sine', 0.2, 0.1), 150);
        setTimeout(() => playTone(600, 'sine', 0.2, 0.1), 300);
        setTimeout(() => playTone(800, 'sine', 0.6, 0.1), 450);
    };

    // --- VISUAL EFFECTS ---
    function spawnSparkles(x, y) {
        const colors = ['#ffd700', '#ff6b6b', '#4facfe', '#43e97b'];
        for (let i = 0; i < 8; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            sparkle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Math to make them fly out in a perfect circle
            const angle = (i / 8) * Math.PI * 2;
            const distance = 40 + Math.random() * 20;
            sparkle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
            sparkle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
            
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 600); // Clean up after animation
        }
    }


    // --- PUZZLE SETTINGS ---
    const rows = 4;
    const cols = 3;
    const pieceSize = 100;
    const bumpSize = 20;

    const puzzleWidth = cols * pieceSize;  
    const puzzleHeight = rows * pieceSize; 

    const imageSrc = "puzzle1.png"; // Replace with your image

    const board = document.getElementById("puzzleBoard");
    const piecesContainer = document.getElementById("pieces");
    let correctPlaced = 0;
    const totalPieces = rows * cols;

    board.style.gridTemplateColumns = `repeat(${cols}, ${pieceSize}px)`;
    board.style.gridTemplateRows = `repeat(${rows}, ${pieceSize}px)`;

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageSrc;
    img.onload = () => initPuzzle();

    function initPuzzle() {
        for (let i = 0; i < totalPieces; i++) {
            const slot = document.createElement("div");
            slot.className = "slot";
            slot.style.width = `${pieceSize}px`;
            slot.style.height = `${pieceSize}px`;
            slot.dataset.index = i;
            board.appendChild(slot);
        }

        let hBumps = [];
        for(let r=0; r<rows-1; r++) {
            let rowBumps = [];
            for(let c=0; c<cols; c++) rowBumps.push(Math.random() > 0.5 ? 1 : -1);
            hBumps.push(rowBumps);
        }
        let vBumps = [];
        for(let r=0; r<rows; r++) {
            let rowBumps = [];
            for(let c=0; c<cols-1; c++) rowBumps.push(Math.random() > 0.5 ? 1 : -1);
            vBumps.push(rowBumps);
        }

        let piecesArray = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const t = (r === 0) ? 0 : -hBumps[r-1][c]; 
                const b = (r === rows - 1) ? 0 : hBumps[r][c];
                const l = (c === 0) ? 0 : -vBumps[r][c-1];
                const rBump = (c === cols - 1) ? 0 : vBumps[r][c];

                const piece = createPieceCanvas(c, r, t, rBump, b, l);
                piece.dataset.index = r * cols + c;
                piecesArray.push(piece);
            }
        }

        piecesArray.sort(() => Math.random() - 0.5);
        piecesArray.forEach(piece => {
            piecesContainer.appendChild(piece);
            enableDrag(piece);
        });
    }

    function createPieceCanvas(col, row, t, r, b, l) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        
        const pw = pieceSize; 
        const ph = pieceSize; 
        
        canvas.width = pw + bumpSize * 2;
        canvas.height = ph + bumpSize * 2;
        canvas.className = "piece";

        ctx.translate(bumpSize, bumpSize); 
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        
        const cx = pw / 2;
        const cy = ph / 2;

        if (t === 0) ctx.lineTo(pw, 0);
        else {
            ctx.lineTo(cx - 15, 0);
            ctx.bezierCurveTo(cx - 25, -bumpSize * 1.5 * t, cx + 25, -bumpSize * 1.5 * t, cx + 15, 0);
            ctx.lineTo(pw, 0);
        }
        if (r === 0) ctx.lineTo(pw, ph);
        else {
            ctx.lineTo(pw, cy - 15);
            ctx.bezierCurveTo(pw + bumpSize * 1.5 * r, cy - 25, pw + bumpSize * 1.5 * r, cy + 25, pw, cy + 15);
            ctx.lineTo(pw, ph);
        }
        if (b === 0) ctx.lineTo(0, ph);
        else {
            ctx.lineTo(cx + 15, ph);
            ctx.bezierCurveTo(cx + 25, ph + bumpSize * 1.5 * b, cx - 25, ph + bumpSize * 1.5 * b, cx - 15, ph);
            ctx.lineTo(0, ph);
        }
        if (l === 0) ctx.lineTo(0, 0);
        else {
            ctx.lineTo(0, cy + 15);
            ctx.bezierCurveTo(-bumpSize * 1.5 * l, cy + 25, -bumpSize * 1.5 * l, cy - 25, 0, cy - 15);
            ctx.lineTo(0, 0);
        }
        ctx.closePath();
        ctx.clip(); 

        const scaleX = img.width / puzzleWidth;
        const scaleY = img.height / puzzleHeight;
        
        const sx = (col * pw - bumpSize) * scaleX;
        const sy = (row * ph - bumpSize) * scaleY;
        const sWidth = canvas.width * scaleX;
        const sHeight = canvas.height * scaleY;

        ctx.drawImage(img, sx, sy, sWidth, sHeight, -bumpSize, -bumpSize, canvas.width, canvas.height);
        
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
        ctx.stroke();

        return canvas;
    }

    function enableDrag(piece) {
        let isDragging = false;
        let offsetX, offsetY;

        piece.addEventListener("pointerdown", startDrag);

        function startDrag(e) {
            if (piece.classList.contains('placed')) return;
            
            sfxPickup(); // Play sound on pickup!

            isDragging = true;
            piece.classList.add('dragging');
            
            const rect = piece.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            document.body.appendChild(piece);
            piece.style.position = "absolute";
            moveAt(e.pageX, e.pageY);

            piece.setPointerCapture(e.pointerId);
            piece.addEventListener("pointermove", onMouseMove);
            piece.addEventListener("pointerup", stopDrag);
        }

        function moveAt(pageX, pageY) {
            piece.style.left = pageX - offsetX + 'px';
            piece.style.top = pageY - offsetY + 'px';
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            moveAt(e.pageX, e.pageY);
        }

        function stopDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            piece.classList.remove('dragging');
            piece.removeEventListener("pointermove", onMouseMove);
            piece.removeEventListener("pointerup", stopDrag);
            piece.releasePointerCapture(e.pointerId);

            checkDropZone(piece, e.clientX, e.clientY);
        }
    }

    function checkDropZone(piece, mouseX, mouseY) {
        const slots = document.querySelectorAll(".slot");
        let droppedCorrectly = false;

        slots.forEach(slot => {
            const rect = slot.getBoundingClientRect();
            
            if (mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
                if (slot.dataset.index === piece.dataset.index) {
                    slot.appendChild(piece);
                    piece.style.position = "absolute";
                    piece.style.left = `-${bumpSize}px`;
                    piece.style.top = `-${bumpSize}px`;
                    piece.classList.add('placed');
                    slot.style.boxShadow = "none";

                    // Trigger Rewards!
                    sfxSnap();
                    spawnSparkles(rect.left + (rect.width / 2), rect.top + (rect.height / 2));

                    droppedCorrectly = true;
                    correctPlaced++;
                    updateProgress();

                    if (correctPlaced === totalPieces) finishGame();
                }
            }
        });

        // If dropped outside/incorrectly
        if (!droppedCorrectly) {
            sfxError(); // Play error boop
            piecesContainer.appendChild(piece);
            piece.style.position = "relative"; 
            piece.style.left = "0";
            piece.style.top = "0";

            // Make the tray wobble a little bit
            piecesContainer.classList.remove("wobble-tray");
            void piecesContainer.offsetWidth; // trigger reflow
            piecesContainer.classList.add("wobble-tray");
        }
    }

    function updateProgress() {
        const percent = (correctPlaced / totalPieces) * 100;
        document.getElementById("progressBar").style.width = percent + "%";
    }

    function finishGame() {
        sfxWin(); // Play victory tune!
        document.getElementById("result").style.opacity = "1";
        
        // Slide tray down and away
        document.getElementById("pieces").style.transform = "translateY(150%)";
        setTimeout(() => document.getElementById("pieces").style.display = "none", 500);
        
        startConfetti();
    }

    function startConfetti() {
        const canvas = document.getElementById("confetti");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particles = [];
        for (let i = 0; i < 250; i++) { // Increased confetti count!
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height - canvas.height,
                size: Math.random() * 8 + 6,
                speedY: Math.random() * 3 + 4, // Make it fall a bit faster
                speedX: Math.random() * 4 - 2, // Make it drift wider
                color: `hsl(${Math.random() * 360}, 100%, 65%)`,
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 10 - 5
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.roundRect(-p.size/2, -p.size/2, p.size, p.size * 1.5, 3);
                ctx.fill();
                ctx.restore();

                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += p.rotationSpeed;

                if (p.y > canvas.height) {
                    p.y = -20;
                    p.x = Math.random() * canvas.width;
                }
            });
            requestAnimationFrame(draw);
        }
        draw();
    }
</script>

</body>
</html>
